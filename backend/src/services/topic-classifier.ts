import { v4 as uuidv4 } from 'uuid';
import { grokFast, grokStrong, parseJsonResponse, ChatMessage } from './grok';
import { normalizeLabels, applyTopicCap } from './label-normalizer';
import { classificationCache } from '../store/classification-cache';
import { HYPERPARAMS } from '../config/hyperparams';
import { Post, TopicSpace } from '../types';

// ============================================
// Topic Classification Service (v2)
// ============================================
// Improved with:
// - Per-post caching
// - Label normalization
// - Topic cap with Long Tail merging
// - Configurable hyperparameters

/**
 * Classification result for a single post
 */
interface PostClassification {
  id: string;
  topic: string;
  summary: string;
}

/**
 * Batch classification response from Grok
 */
interface ClassificationResponse {
  classifications: PostClassification[];
}

/**
 * Topic info generated by Grok
 */
interface TopicInfo {
  title: string;
  description: string;
}

/**
 * Stats from a classification run
 */
export interface ClassificationStats {
  totalPosts: number;
  cachedPosts: number;
  classifiedPosts: number;
  rawLabelCount: number;
  canonicalLabelCount: number;
  topicSpaceCount: number;
  longTailPostCount: number;
  grokCallsClassification: number;
  grokCallsNormalization: number;
  grokCallsDescriptions: number;
}

/**
 * Classify posts with caching support
 * Only sends uncached/changed posts to Grok
 */
export async function classifyPosts(
  posts: Post[],
  xUserId: string,
  existingTopics: string[] = []
): Promise<{ classifiedPosts: Post[]; stats: Partial<ClassificationStats> }> {
  if (posts.length === 0) {
    return { classifiedPosts: [], stats: { totalPosts: 0, cachedPosts: 0, classifiedPosts: 0 } };
  }

  const classifiedPosts: Post[] = [];
  const postsToClassify: Post[] = [];
  let cachedCount = 0;

  // Step 1: Check cache for each post
  if (HYPERPARAMS.ENABLE_CACHE && HYPERPARAMS.SKIP_CACHED_POSTS) {
    for (const post of posts) {
      const cached = classificationCache.get(xUserId, post.id, post.text);
      
      if (cached) {
        // Use cached classification
        classifiedPosts.push({
          ...post,
          topicLabel: cached.topicLabel,
          summary: cached.summary,
        });
        cachedCount++;
      } else {
        // Need to classify
        postsToClassify.push(post);
      }
    }

    if (HYPERPARAMS.LOG_CACHE_STATS) {
      console.log(`  Cache: ${cachedCount}/${posts.length} posts cached, ${postsToClassify.length} to classify`);
    }
  } else {
    postsToClassify.push(...posts);
  }

  // Step 2: Classify uncached posts in batches
  let grokCalls = 0;
  const batchSize = HYPERPARAMS.CLASSIFICATION_BATCH_SIZE;

  for (let i = 0; i < postsToClassify.length; i += batchSize) {
    const batch = postsToClassify.slice(i, i + batchSize);
    const batchNum = Math.floor(i / batchSize) + 1;
    const totalBatches = Math.ceil(postsToClassify.length / batchSize);
    console.log(`  Classifying batch ${batchNum}/${totalBatches} (${batch.length} posts)...`);
    
    try {
      const batchResults = await classifyBatch(batch, existingTopics);
      grokCalls++;
      
      // Process results and cache them
      const cacheEntries: Array<{ postId: string; text: string; topicLabel: string; summary: string }> = [];
      
      for (const post of batch) {
        const classification = batchResults.find(c => c.id === post.id);
        
        if (classification) {
          classifiedPosts.push({
            ...post,
            topicLabel: classification.topic,
            summary: classification.summary,
          });
          
          cacheEntries.push({
            postId: post.id,
            text: post.text,
            topicLabel: classification.topic,
            summary: classification.summary,
          });
          
          // Track topics for consistency
          if (!existingTopics.includes(classification.topic)) {
            existingTopics.push(classification.topic);
          }
        } else {
          // Classification failed for this post
          classifiedPosts.push({
            ...post,
            topicLabel: 'Uncategorized',
            summary: post.text.slice(0, 100) + (post.text.length > 100 ? '...' : ''),
          });
        }
      }
      
      // Batch cache the results
      classificationCache.setMany(xUserId, cacheEntries);
      
    } catch (error) {
      console.error(`  Error classifying batch:`, error);
      grokCalls++;
      
      // On error, add posts with default values
      for (const post of batch) {
        classifiedPosts.push({
          ...post,
          topicLabel: 'Uncategorized',
          summary: post.text.slice(0, 100) + (post.text.length > 100 ? '...' : ''),
        });
      }
    }
  }

  return {
    classifiedPosts,
    stats: {
      totalPosts: posts.length,
      cachedPosts: cachedCount,
      classifiedPosts: postsToClassify.length,
      grokCallsClassification: grokCalls,
    },
  };
}

/**
 * Classify a single batch of posts
 */
async function classifyBatch(
  posts: Post[],
  existingTopics: string[]
): Promise<PostClassification[]> {
  const maxTextLen = HYPERPARAMS.CLASSIFICATION_MAX_TEXT_LENGTH;
  
  const postsText = posts.map((p, idx) => 
    `[${idx + 1}] ID: ${p.id}\n@${p.authorUsername}: ${p.text.slice(0, maxTextLen)}`
  ).join('\n\n');

  const topicsHint = existingTopics.length > 0 
    ? `\nPrefer using these existing topics when appropriate: ${existingTopics.slice(0, 20).join(', ')}\nBut create new topics if the content doesn't fit.`
    : '';

  const systemPrompt = `You are a tweet classifier. Your job is to:
1. Assign each tweet to a topic category (e.g., "AI/ML", "GPU Programming", "Startups", "Science", "Politics", etc.)
2. Write a 1-2 sentence summary of each tweet

Guidelines:
- Topic names should be concise (2-4 words max)
- Topics should be specific enough to be useful but general enough to group related tweets
- Summaries should capture the key point, not just repeat the tweet
- Base everything ONLY on the tweet content provided
${topicsHint}

Return your response as JSON with this exact structure:
{
  "classifications": [
    { "id": "tweet_id", "topic": "Topic Name", "summary": "Brief summary" },
    ...
  ]
}`;

  const userPrompt = `Classify these ${posts.length} tweets:\n\n${postsText}`;

  const messages: ChatMessage[] = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ];

  const response = await grokFast(messages, {
    temperature: HYPERPARAMS.CLASSIFICATION_TEMPERATURE,
    response_format: { type: 'json_object' },
  });

  console.log(`    Model: ${response.model}, tokens: ${response.usage.total_tokens}`);

  const parsed = parseJsonResponse<ClassificationResponse>(response.content);
  return parsed.classifications;
}

/**
 * Group classified posts by topic label
 */
export function groupPostsByTopic(posts: Post[]): Map<string, Post[]> {
  const topicGroups = new Map<string, Post[]>();

  for (const post of posts) {
    const topic = post.topicLabel || 'Uncategorized';
    const existing = topicGroups.get(topic) || [];
    existing.push(post);
    topicGroups.set(topic, existing);
  }

  return topicGroups;
}

/**
 * Count posts per label
 */
function countLabels(posts: Post[]): Map<string, number> {
  const counts = new Map<string, number>();
  
  for (const post of posts) {
    const label = post.topicLabel || 'Uncategorized';
    counts.set(label, (counts.get(label) || 0) + 1);
  }
  
  return counts;
}

/**
 * Apply label mapping to posts
 */
function applyLabelMapping(posts: Post[], mapping: Map<string, string>): Post[] {
  return posts.map(post => {
    const originalLabel = post.topicLabel || 'Uncategorized';
    const newLabel = mapping.get(originalLabel) || originalLabel;
    return { ...post, topicLabel: newLabel };
  });
}

/**
 * Generate title and description for a topic using Grok
 */
export async function generateTopicInfo(
  canonicalLabel: string,
  posts: Post[]
): Promise<TopicInfo> {
  // For Long Tail, use a static description
  if (canonicalLabel === HYPERPARAMS.LONG_TAIL_LABEL) {
    return {
      title: 'Miscellaneous',
      description: `Collection of ${posts.length} posts across various smaller topics.`,
    };
  }

  // For small topics, use simpler description
  if (posts.length < HYPERPARAMS.MIN_POSTS_FOR_DESCRIPTION) {
    return {
      title: canonicalLabel,
      description: `${posts.length} post${posts.length === 1 ? '' : 's'} about ${canonicalLabel.toLowerCase()}.`,
    };
  }

  // Sample posts for the prompt
  const samplePosts = posts.slice(0, HYPERPARAMS.MAX_SAMPLE_POSTS_FOR_DESCRIPTION);
  const summaries = samplePosts
    .map(p => `- ${p.summary || p.text.slice(0, 100)}`)
    .join('\n');

  const systemPrompt = `You are creating a title and description for a Topic Space (a collection of related tweets).

Guidelines:
- Title should be catchy but informative (3-6 words)
- Use the canonical label as a strong hint for the title
- Description should be 1-2 sentences explaining what this topic covers
- Base everything ONLY on the tweet summaries provided
- Don't make up information not in the tweets

Return JSON: { "title": "Topic Title", "description": "Brief description" }`;

  const userPrompt = `Canonical label: "${canonicalLabel}"
Number of posts: ${posts.length}

Sample post summaries:
${summaries}`;

  try {
    const response = await grokStrong(
      [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      {
        temperature: HYPERPARAMS.TOPIC_DESCRIPTION_TEMPERATURE,
        response_format: { type: 'json_object' },
      }
    );

    return parseJsonResponse<TopicInfo>(response.content);
  } catch (error) {
    console.error(`  Error generating topic info for "${canonicalLabel}":`, error);
    return {
      title: canonicalLabel,
      description: `${posts.length} posts about ${canonicalLabel.toLowerCase()}.`,
    };
  }
}

/**
 * Create TopicSpaces from classified posts
 */
export async function createTopicSpaces(
  posts: Post[],
  generateDescriptions: boolean = true
): Promise<{ topicSpaces: TopicSpace[]; grokCalls: number }> {
  const topicGroups = groupPostsByTopic(posts);
  const topicSpaces: TopicSpace[] = [];
  let grokCalls = 0;

  // Sort topics by number of posts (descending)
  const sortedTopics = Array.from(topicGroups.entries())
    .sort((a, b) => b[1].length - a[1].length);

  for (const [topicLabel, topicPosts] of sortedTopics) {
    let title = topicLabel;
    let description = `${topicPosts.length} posts about ${topicLabel.toLowerCase()}`;

    if (generateDescriptions) {
      try {
        const info = await generateTopicInfo(topicLabel, topicPosts);
        title = info.title;
        description = info.description;
        
        // Only count as Grok call if we actually called Grok
        if (topicLabel !== HYPERPARAMS.LONG_TAIL_LABEL && 
            topicPosts.length >= HYPERPARAMS.MIN_POSTS_FOR_DESCRIPTION) {
          grokCalls++;
        }
      } catch (error) {
        console.error(`  Failed to generate info for topic "${topicLabel}"`);
      }
    }

    const now = new Date().toISOString();
    topicSpaces.push({
      id: uuidv4(),
      title,
      description,
      postIds: topicPosts.map(p => p.id),
      createdAt: now,
      updatedAt: now,
      newPostCount: 0,
    });
  }

  return { topicSpaces, grokCalls };
}

/**
 * Full pipeline: classify posts and create TopicSpaces
 * With caching, normalization, and topic cap
 */
export async function classifyAndCreateTopicSpaces(
  posts: Post[],
  xUserId: string,
  existingTopics: string[] = []
): Promise<{ posts: Post[]; topicSpaces: TopicSpace[]; stats: ClassificationStats }> {
  console.log(`\n=== Starting Classification Pipeline ===`);
  console.log(`  Posts: ${posts.length}, Cache: ${HYPERPARAMS.ENABLE_CACHE ? 'ON' : 'OFF'}, Normalization: ${HYPERPARAMS.ENABLE_NORMALIZATION ? 'ON' : 'OFF'}`);
  
  // Initialize stats
  const stats: ClassificationStats = {
    totalPosts: posts.length,
    cachedPosts: 0,
    classifiedPosts: 0,
    rawLabelCount: 0,
    canonicalLabelCount: 0,
    topicSpaceCount: 0,
    longTailPostCount: 0,
    grokCallsClassification: 0,
    grokCallsNormalization: 0,
    grokCallsDescriptions: 0,
  };

  if (posts.length === 0) {
    return { posts: [], topicSpaces: [], stats };
  }

  // Step 1: Classify posts (with caching)
  console.log(`\n[Step 1] Classifying posts...`);
  const { classifiedPosts, stats: classifyStats } = await classifyPosts(posts, xUserId, existingTopics);
  stats.cachedPosts = classifyStats.cachedPosts || 0;
  stats.classifiedPosts = classifyStats.classifiedPosts || 0;
  stats.grokCallsClassification = classifyStats.grokCallsClassification || 0;

  // Count raw labels
  const rawLabelCounts = countLabels(classifiedPosts);
  stats.rawLabelCount = rawLabelCounts.size;
  console.log(`  Raw labels: ${stats.rawLabelCount}`);

  // Step 2: Normalize labels (if enabled)
  console.log(`\n[Step 2] Normalizing labels...`);
  const normResult = await normalizeLabels(rawLabelCounts);
  if (normResult.success && HYPERPARAMS.ENABLE_NORMALIZATION) {
    stats.grokCallsNormalization = 1;
  }
  
  // Step 3: Apply topic cap
  console.log(`\n[Step 3] Applying topic cap...`);
  const finalMapping = applyTopicCap(rawLabelCounts, normResult.mapping);
  
  // Apply mapping to posts
  const normalizedPosts = applyLabelMapping(classifiedPosts, finalMapping);
  
  // Update cache with normalized labels
  if (HYPERPARAMS.ENABLE_CACHE) {
    classificationCache.applyNormalization(xUserId, finalMapping);
  }
  
  // Count canonical labels (excluding Long Tail)
  const canonicalCounts = countLabels(normalizedPosts);
  stats.canonicalLabelCount = Array.from(canonicalCounts.keys())
    .filter(l => l !== HYPERPARAMS.LONG_TAIL_LABEL).length;
  stats.longTailPostCount = canonicalCounts.get(HYPERPARAMS.LONG_TAIL_LABEL) || 0;
  
  console.log(`  Canonical labels: ${stats.canonicalLabelCount}`);
  if (stats.longTailPostCount > 0) {
    console.log(`  Long Tail posts: ${stats.longTailPostCount}`);
  }

  // Step 4: Create TopicSpaces
  console.log(`\n[Step 4] Creating Topic Spaces...`);
  const { topicSpaces, grokCalls: descriptionCalls } = await createTopicSpaces(normalizedPosts);
  stats.topicSpaceCount = topicSpaces.length;
  stats.grokCallsDescriptions = descriptionCalls;

  // Log final stats
  if (HYPERPARAMS.LOG_CLASSIFICATION_STATS) {
    console.log(`\n=== Classification Complete ===`);
    console.log(`  Total posts: ${stats.totalPosts}`);
    console.log(`  Cached: ${stats.cachedPosts}, Classified: ${stats.classifiedPosts}`);
    console.log(`  Raw labels: ${stats.rawLabelCount} â†’ Canonical: ${stats.canonicalLabelCount}`);
    console.log(`  Topic Spaces: ${stats.topicSpaceCount}`);
    console.log(`  Grok calls: ${stats.grokCallsClassification} classification + ${stats.grokCallsNormalization} normalization + ${stats.grokCallsDescriptions} descriptions`);
    console.log(`================================\n`);
  }

  return { posts: normalizedPosts, topicSpaces, stats };
}
