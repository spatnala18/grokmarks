import { v4 as uuidv4 } from 'uuid';
import { grokFast, parseJsonResponse, ChatMessage } from './grok';
import { Post, TopicSpace } from '../types';

// ============================================
// Topic Classification Service
// ============================================

/**
 * Classification result for a single post
 */
interface PostClassification {
  id: string;
  topic: string;
  summary: string;
}

/**
 * Batch classification response from Grok
 */
interface ClassificationResponse {
  classifications: PostClassification[];
}

/**
 * Topic info generated by Grok
 */
interface TopicInfo {
  title: string;
  description: string;
}

/**
 * Classify a batch of posts into topics and generate summaries
 * 
 * @param posts - Array of posts to classify
 * @param existingTopics - Optional list of existing topic names to prefer
 * @param batchSize - Number of posts per Grok request (default 20)
 */
export async function classifyPosts(
  posts: Post[],
  existingTopics: string[] = [],
  batchSize: number = 20
): Promise<Post[]> {
  if (posts.length === 0) return [];

  const classifiedPosts: Post[] = [];
  
  // Process in batches to avoid token limits
  for (let i = 0; i < posts.length; i += batchSize) {
    const batch = posts.slice(i, i + batchSize);
    console.log(`Classifying batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(posts.length / batchSize)}...`);
    
    try {
      const batchResults = await classifyBatch(batch, existingTopics);
      
      // Merge classification results into posts
      for (const post of batch) {
        const classification = batchResults.find(c => c.id === post.id);
        if (classification) {
          classifiedPosts.push({
            ...post,
            topicLabel: classification.topic,
            summary: classification.summary,
          });
          
          // Add new topic to existing topics for consistency
          if (!existingTopics.includes(classification.topic)) {
            existingTopics.push(classification.topic);
          }
        } else {
          // If classification failed, keep post with default values
          classifiedPosts.push({
            ...post,
            topicLabel: 'Uncategorized',
            summary: post.text.slice(0, 100) + (post.text.length > 100 ? '...' : ''),
          });
        }
      }
    } catch (error) {
      console.error(`Error classifying batch:`, error);
      // On error, add posts with default values
      for (const post of batch) {
        classifiedPosts.push({
          ...post,
          topicLabel: 'Uncategorized',
          summary: post.text.slice(0, 100) + (post.text.length > 100 ? '...' : ''),
        });
      }
    }
  }

  return classifiedPosts;
}

/**
 * Classify a single batch of posts
 */
async function classifyBatch(
  posts: Post[],
  existingTopics: string[]
): Promise<PostClassification[]> {
  // Build the prompt
  const postsText = posts.map((p, idx) => 
    `[${idx + 1}] ID: ${p.id}\n@${p.authorUsername}: ${p.text.slice(0, 500)}`
  ).join('\n\n');

  const topicsHint = existingTopics.length > 0 
    ? `\nPrefer using these existing topics when appropriate: ${existingTopics.join(', ')}\nBut create new topics if the content doesn't fit.`
    : '';

  const systemPrompt = `You are a tweet classifier. Your job is to:
1. Assign each tweet to a topic category (e.g., "AI/ML", "GPU Programming", "Startups", "Science", "Politics", etc.)
2. Write a 1-2 sentence summary of each tweet

Guidelines:
- Topic names should be concise (2-4 words max)
- Topics should be specific enough to be useful but general enough to group related tweets
- Summaries should capture the key point, not just repeat the tweet
- Base everything ONLY on the tweet content provided
${topicsHint}

Return your response as JSON with this exact structure:
{
  "classifications": [
    { "id": "tweet_id", "topic": "Topic Name", "summary": "Brief summary" },
    ...
  ]
}`;

  const userPrompt = `Classify these ${posts.length} tweets:\n\n${postsText}`;

  const messages: ChatMessage[] = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ];

  const response = await grokFast(messages, {
    temperature: 0.3, // Lower temperature for more consistent classification
    response_format: { type: 'json_object' },
  });

  console.log(`  Used model: ${response.model}, tokens: ${response.usage.total_tokens}`);

  const parsed = parseJsonResponse<ClassificationResponse>(response.content);
  return parsed.classifications;
}

/**
 * Group classified posts into TopicSpaces
 */
export function groupPostsByTopic(posts: Post[]): Map<string, Post[]> {
  const topicGroups = new Map<string, Post[]>();

  for (const post of posts) {
    const topic = post.topicLabel || 'Uncategorized';
    const existing = topicGroups.get(topic) || [];
    existing.push(post);
    topicGroups.set(topic, existing);
  }

  return topicGroups;
}

/**
 * Generate title and description for a topic based on its posts
 */
export async function generateTopicInfo(
  topicLabel: string,
  posts: Post[]
): Promise<TopicInfo> {
  // For small topics, use simpler description
  if (posts.length < 3) {
    return {
      title: topicLabel,
      description: `Collection of ${posts.length} post${posts.length === 1 ? '' : 's'} about ${topicLabel.toLowerCase()}.`,
    };
  }

  // Sample posts for the prompt (max 10)
  const samplePosts = posts.slice(0, 10);
  const summaries = samplePosts
    .map(p => `- ${p.summary || p.text.slice(0, 100)}`)
    .join('\n');

  const systemPrompt = `You are creating a title and description for a Topic Space (a collection of related tweets).

Guidelines:
- Title should be catchy but informative (3-6 words)
- Description should be 1-2 sentences explaining what this topic covers
- Base everything ONLY on the tweet summaries provided
- Don't make up information not in the tweets

Return JSON: { "title": "Topic Title", "description": "Brief description" }`;

  const userPrompt = `Topic label: "${topicLabel}"
Number of posts: ${posts.length}

Sample post summaries:
${summaries}`;

  try {
    const response = await grokFast(
      [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      {
        temperature: 0.5,
        response_format: { type: 'json_object' },
      }
    );

    return parseJsonResponse<TopicInfo>(response.content);
  } catch (error) {
    console.error(`Error generating topic info for "${topicLabel}":`, error);
    return {
      title: topicLabel,
      description: `Collection of ${posts.length} posts about ${topicLabel.toLowerCase()}.`,
    };
  }
}

/**
 * Create TopicSpaces from classified posts
 */
export async function createTopicSpaces(
  posts: Post[],
  generateDescriptions: boolean = true
): Promise<TopicSpace[]> {
  const topicGroups = groupPostsByTopic(posts);
  const topicSpaces: TopicSpace[] = [];

  // Sort topics by number of posts (descending)
  const sortedTopics = Array.from(topicGroups.entries())
    .sort((a, b) => b[1].length - a[1].length);

  for (const [topicLabel, topicPosts] of sortedTopics) {
    let title = topicLabel;
    let description = `${topicPosts.length} posts about ${topicLabel.toLowerCase()}`;

    // Generate better title/description for larger topics
    if (generateDescriptions && topicPosts.length >= 3) {
      try {
        const info = await generateTopicInfo(topicLabel, topicPosts);
        title = info.title;
        description = info.description;
      } catch (error) {
        console.error(`Failed to generate info for topic "${topicLabel}"`);
      }
    }

    const now = new Date().toISOString();
    topicSpaces.push({
      id: uuidv4(),
      title,
      description,
      postIds: topicPosts.map(p => p.id),
      createdAt: now,
      updatedAt: now,
      newPostCount: 0,
    });
  }

  return topicSpaces;
}

/**
 * Full pipeline: classify posts and create TopicSpaces
 */
export async function classifyAndCreateTopicSpaces(
  posts: Post[],
  existingTopics: string[] = []
): Promise<{ posts: Post[]; topicSpaces: TopicSpace[] }> {
  console.log(`Starting classification of ${posts.length} posts...`);
  
  // Step 1: Classify posts
  const classifiedPosts = await classifyPosts(posts, existingTopics);
  console.log(`Classification complete. Found ${new Set(classifiedPosts.map(p => p.topicLabel)).size} unique topics.`);

  // Step 2: Create TopicSpaces
  console.log('Creating Topic Spaces...');
  const topicSpaces = await createTopicSpaces(classifiedPosts);
  console.log(`Created ${topicSpaces.length} Topic Spaces.`);

  return { posts: classifiedPosts, topicSpaces };
}
