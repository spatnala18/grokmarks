import { v4 as uuidv4 } from 'uuid';
import { grokFast, grokStrong, parseJsonResponse, ChatMessage } from './grok';
import { normalizeLabels, applyTopicCap } from './label-normalizer';
import { classificationCache } from '../store/classification-cache';
import { HYPERPARAMS } from '../config/hyperparams';
import { Post, TopicSpace, TopicType } from '../types';

// ============================================
// Topic Classification Service (v3)
// ============================================
// Features:
// - Per-post caching
// - Label normalization
// - Topic cap with Long Tail merging
// - Configurable hyperparameters
// - Bookmarks-only classification
// - Custom topics support
// - Multi-topic assignment (when appropriate)

/**
 * Classification result for a single post
 * Supports multiple topics
 */
interface PostClassification {
  id: string;
  topics: string[];  // Can be multiple topics (usually 1, rarely 2+)
  summary: string;
}

/**
 * Batch classification response from Grok
 */
interface ClassificationResponse {
  classifications: PostClassification[];
}

/**
 * Topic info generated by Grok
 */
interface TopicInfo {
  title: string;
  description: string;
}

/**
 * Options for classification
 */
export interface ClassificationOptions {
  topicType: TopicType;              // 'auto' or 'custom'
  customTopicNames?: string[];       // User-provided topic names (for custom type)
}

/**
 * Stats from a classification run
 */
export interface ClassificationStats {
  totalPosts: number;
  cachedPosts: number;
  classifiedPosts: number;
  rawLabelCount: number;
  canonicalLabelCount: number;
  topicSpaceCount: number;
  longTailPostCount: number;
  grokCallsClassification: number;
  grokCallsNormalization: number;
  grokCallsDescriptions: number;
}

/**
 * Filter posts to only include bookmarks
 */
export function filterBookmarksOnly(posts: Post[]): Post[] {
  return posts.filter(p => p.source === 'bookmark');
}

/**
 * Classify posts with caching support
 * Only sends uncached/changed posts to Grok
 */
export async function classifyPosts(
  posts: Post[],
  xUserId: string,
  options: ClassificationOptions = { topicType: 'auto' }
): Promise<{ classifiedPosts: Post[]; stats: Partial<ClassificationStats> }> {
  if (posts.length === 0) {
    return { classifiedPosts: [], stats: { totalPosts: 0, cachedPosts: 0, classifiedPosts: 0 } };
  }

  const classifiedPosts: Post[] = [];
  const postsToClassify: Post[] = [];
  let cachedCount = 0;

  // For custom topics, we skip cache since the topic names are user-defined
  const useCache = options.topicType === 'auto' && HYPERPARAMS.ENABLE_CACHE && HYPERPARAMS.SKIP_CACHED_POSTS;

  // Step 1: Check cache for each post (only for auto topics)
  if (useCache) {
    for (const post of posts) {
      const cached = classificationCache.get(xUserId, post.id, post.text);
      
      if (cached) {
        // Use cached classification
        classifiedPosts.push({
          ...post,
          topicLabels: [cached.topicLabel],
          summary: cached.summary,
        });
        cachedCount++;
      } else {
        postsToClassify.push(post);
      }
    }

    if (HYPERPARAMS.LOG_CACHE_STATS) {
      console.log(`  Cache: ${cachedCount}/${posts.length} posts cached, ${postsToClassify.length} to classify`);
    }
  } else {
    postsToClassify.push(...posts);
  }

  // Step 2: Classify uncached posts in batches
  let grokCalls = 0;
  const batchSize = HYPERPARAMS.CLASSIFICATION_BATCH_SIZE;

  // Collect all classifications first
  const allClassifications: Array<{ post: Post; topics: string[]; summary: string }> = [];

  for (let i = 0; i < postsToClassify.length; i += batchSize) {
    const batch = postsToClassify.slice(i, i + batchSize);
    const batchNum = Math.floor(i / batchSize) + 1;
    const totalBatches = Math.ceil(postsToClassify.length / batchSize);
    console.log(`  Classifying batch ${batchNum}/${totalBatches} (${batch.length} posts)...`);
    
    try {
      const batchResults = await classifyBatch(batch, options);
      grokCalls++;
      
      for (const post of batch) {
        const classification = batchResults.find(c => c.id === post.id);
        
        if (classification && classification.topics.length > 0) {
          allClassifications.push({
            post,
            topics: classification.topics,
            summary: classification.summary,
          });
        } else {
          // Classification failed for this post
          const fallbackTopic = options.topicType === 'custom' ? 'Miscellaneous' : 'Uncategorized';
          allClassifications.push({
            post,
            topics: [fallbackTopic],
            summary: post.text.slice(0, 100) + (post.text.length > 100 ? '...' : ''),
          });
        }
      }
      
    } catch (error) {
      console.error(`  Error classifying batch:`, error);
      grokCalls++;
      
      // On error, add posts with default values
      const fallbackTopic = options.topicType === 'custom' ? 'Miscellaneous' : 'Uncategorized';
      for (const post of batch) {
        allClassifications.push({
          post,
          topics: [fallbackTopic],
          summary: post.text.slice(0, 100) + (post.text.length > 100 ? '...' : ''),
        });
      }
    }
  }

  // Step 2b: For custom topics, map AI-generated labels to exact user-provided names
  let topicMapping: Map<string, string> | null = null;
  if (options.topicType === 'custom' && options.customTopicNames && options.customTopicNames.length > 0) {
    // Collect all unique AI-generated topic names
    const aiGeneratedTopics = new Set<string>();
    for (const c of allClassifications) {
      for (const topic of c.topics) {
        aiGeneratedTopics.add(topic);
      }
    }
    
    // Call LLM to map AI topics to user topics
    topicMapping = await mapTopicsToUserNames(
      Array.from(aiGeneratedTopics),
      options.customTopicNames
    );
    grokCalls++;
    
    console.log(`  Topic mapping:`);
    for (const [ai, user] of topicMapping) {
      console.log(`    "${ai}" → "${user}"`);
    }
  }

  // Step 2c: Apply mapping and build final classified posts
  const cacheEntries: Array<{ postId: string; text: string; topicLabel: string; summary: string }> = [];
  
  for (const { post, topics, summary } of allClassifications) {
    // Apply topic mapping if available
    const finalTopics = topicMapping
      ? topics.map(t => topicMapping!.get(t) || 'Miscellaneous')
      : topics;
    
    classifiedPosts.push({
      ...post,
      topicLabels: finalTopics,
      summary,
    });
    
    // Cache only for auto topics
    if (options.topicType === 'auto') {
      cacheEntries.push({
        postId: post.id,
        text: post.text,
        topicLabel: finalTopics[0],
        summary,
      });
    }
  }
  
  // Batch cache the results (only for auto topics)
  if (options.topicType === 'auto' && cacheEntries.length > 0) {
    classificationCache.setMany(xUserId, cacheEntries);
  }

  return {
    classifiedPosts,
    stats: {
      totalPosts: posts.length,
      cachedPosts: cachedCount,
      classifiedPosts: postsToClassify.length,
      grokCallsClassification: grokCalls,
    },
  };
}

/**
 * Classify a single batch of posts
 */
async function classifyBatch(
  posts: Post[],
  options: ClassificationOptions
): Promise<PostClassification[]> {
  const maxTextLen = HYPERPARAMS.CLASSIFICATION_MAX_TEXT_LENGTH;
  
  const postsText = posts.map((p, idx) => 
    `[${idx + 1}] ID: ${p.id}\n@${p.authorUsername}: ${p.text.slice(0, maxTextLen)}`
  ).join('\n\n');

  let systemPrompt: string;
  
  if (options.topicType === 'custom' && options.customTopicNames && options.customTopicNames.length > 0) {
    // Custom topics: classify into user-provided categories
    const topicsList = options.customTopicNames.map((t, i) => `${i + 1}. "${t}"`).join('\n');
    systemPrompt = `You are a tweet classifier. Your job is to:
1. Assign each tweet to ONE of these EXACT user-defined topics:
${topicsList}
${options.customTopicNames.length + 1}. "Miscellaneous"

2. Write a 1-2 sentence summary of each tweet

CRITICAL RULES:
- You MUST use the EXACT topic names as listed above - do not modify, rephrase, or abbreviate them
- Use the topic name EXACTLY as written in quotes (e.g., "${options.customTopicNames[0]}" not a variation)
- If a tweet doesn't clearly fit any of the provided topics, use exactly "Miscellaneous"
- Most tweets should go to exactly ONE topic
- Summaries should capture the key point, not just repeat the tweet

Return your response as JSON with this exact structure:
{
  "classifications": [
    { "id": "tweet_id", "topics": ["${options.customTopicNames[0]}"], "summary": "Brief summary" },
    { "id": "tweet_id2", "topics": ["Miscellaneous"], "summary": "Brief summary" },
    ...
  ]
}`;
  } else {
    // Auto topics: let Grok discover categories
    systemPrompt = `You are a tweet classifier. Your job is to:
1. Assign each tweet to ONE topic category (e.g., "AI/ML", "GPU Programming", "Startups", "Science", "Politics", etc.)
2. Write a 1-2 sentence summary of each tweet

Guidelines:
- Topic names should be concise (2-4 words max)
- Topics should be specific enough to be useful but general enough to group related tweets
- Most tweets should go to exactly ONE topic
- Only use multiple topics if genuinely applicable (rare)
- Summaries should capture the key point, not just repeat the tweet
- Base everything ONLY on the tweet content provided

Return your response as JSON with this exact structure:
{
  "classifications": [
    { "id": "tweet_id", "topics": ["Topic Name"], "summary": "Brief summary" },
    ...
  ]
}`;
  }

  const userPrompt = `Classify these ${posts.length} tweets:\n\n${postsText}`;

  const messages: ChatMessage[] = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ];

  const response = await grokFast(messages, {
    temperature: HYPERPARAMS.CLASSIFICATION_TEMPERATURE,
    response_format: { type: 'json_object' },
  });

  console.log(`    Model: ${response.model}, tokens: ${response.usage.total_tokens}`);

  const parsed = parseJsonResponse<ClassificationResponse>(response.content);
  return parsed.classifications;
}

/**
 * Map AI-generated topic names to exact user-provided topic names
 * Uses a fast LLM call to do semantic matching
 */
async function mapTopicsToUserNames(
  aiTopics: string[],
  userTopics: string[]
): Promise<Map<string, string>> {
  const mapping = new Map<string, string>();
  
  // If no AI topics, return empty mapping
  if (aiTopics.length === 0) return mapping;
  
  // Build the valid topics list (user topics + Miscellaneous)
  const validTopics = [...userTopics, 'Miscellaneous'];
  
  const systemPrompt = `You are a topic name mapper. Your job is to map AI-generated topic names to the EXACT user-provided topic names.

The user provided these EXACT topic names (use these EXACTLY as written):
${userTopics.map((t, i) => `${i + 1}. "${t}"`).join('\n')}
${userTopics.length + 1}. "Miscellaneous" (for topics that don't match any of the above)

For each AI-generated topic, output the EXACT matching user topic name from the list above.
If an AI topic doesn't clearly match any user topic, map it to "Miscellaneous".

Return JSON with this exact structure:
{
  "mappings": [
    { "ai_topic": "AI generated name", "user_topic": "Exact User Topic Name" },
    ...
  ]
}`;

  const userPrompt = `Map these AI-generated topic names to the exact user topic names:

AI-generated topics:
${aiTopics.map((t, i) => `${i + 1}. "${t}"`).join('\n')}

Remember: Output must use EXACT user topic names from the list, or "Miscellaneous".`;

  const messages: ChatMessage[] = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ];

  try {
    const response = await grokFast(messages, {
      temperature: 0, // Deterministic for mapping
      response_format: { type: 'json_object' },
    });

    console.log(`  Topic mapping LLM call: ${response.usage.total_tokens} tokens`);

    interface MappingResponse {
      mappings: Array<{ ai_topic: string; user_topic: string }>;
    }

    const parsed = parseJsonResponse<MappingResponse>(response.content);
    
    // Build the mapping, ensuring only valid topics are used
    for (const { ai_topic, user_topic } of parsed.mappings) {
      // Verify the user_topic is in our valid list (case-insensitive check)
      const matchedTopic = validTopics.find(
        t => t.toLowerCase() === user_topic.toLowerCase()
      );
      mapping.set(ai_topic, matchedTopic || 'Miscellaneous');
    }
    
    // Ensure all AI topics have a mapping
    for (const aiTopic of aiTopics) {
      if (!mapping.has(aiTopic)) {
        mapping.set(aiTopic, 'Miscellaneous');
      }
    }
    
  } catch (error) {
    console.error('  Error in topic mapping:', error);
    // Fallback: map everything to Miscellaneous
    for (const aiTopic of aiTopics) {
      mapping.set(aiTopic, 'Miscellaneous');
    }
  }
  
  return mapping;
}

/**
 * Group classified posts by topic label
 * Since posts can have multiple topics, a post may appear in multiple groups
 */
export function groupPostsByTopic(posts: Post[]): Map<string, Post[]> {
  const topicGroups = new Map<string, Post[]>();

  for (const post of posts) {
    const topics = post.topicLabels || ['Uncategorized'];
    
    for (const topic of topics) {
      const existing = topicGroups.get(topic) || [];
      existing.push(post);
      topicGroups.set(topic, existing);
    }
  }

  return topicGroups;
}

/**
 * Count posts per label (counting each post once per topic it belongs to)
 */
function countLabels(posts: Post[]): Map<string, number> {
  const counts = new Map<string, number>();
  
  for (const post of posts) {
    const topics = post.topicLabels || ['Uncategorized'];
    for (const topic of topics) {
      counts.set(topic, (counts.get(topic) || 0) + 1);
    }
  }
  
  return counts;
}

/**
 * Apply label mapping to posts
 */
function applyLabelMapping(posts: Post[], mapping: Map<string, string>): Post[] {
  return posts.map(post => {
    const originalTopics = post.topicLabels || ['Uncategorized'];
    const newTopics = originalTopics.map(t => mapping.get(t) || t);
    // Deduplicate after mapping
    const uniqueTopics = [...new Set(newTopics)];
    return { ...post, topicLabels: uniqueTopics };
  });
}

/**
 * Compute the lastBookmarkTime for a set of posts
 */
function computeLastBookmarkTime(posts: Post[]): string {
  if (posts.length === 0) {
    return new Date().toISOString();
  }
  
  let maxTime = 0;
  for (const post of posts) {
    const time = new Date(post.createdAt).getTime();
    if (time > maxTime) {
      maxTime = time;
    }
  }
  
  return new Date(maxTime).toISOString();
}

/**
 * Generate title and description for a topic using Grok
 */
export async function generateTopicInfo(
  canonicalLabel: string,
  posts: Post[]
): Promise<TopicInfo> {
  // For Long Tail, use a static description
  if (canonicalLabel === HYPERPARAMS.LONG_TAIL_LABEL) {
    return {
      title: 'Miscellaneous',
      description: `Collection of ${posts.length} posts across various smaller topics.`,
    };
  }

  // For small topics, use simpler description
  if (posts.length < HYPERPARAMS.MIN_POSTS_FOR_DESCRIPTION) {
    return {
      title: canonicalLabel,
      description: `${posts.length} post${posts.length === 1 ? '' : 's'} about ${canonicalLabel.toLowerCase()}.`,
    };
  }

  // Sample posts for the prompt
  const samplePosts = posts.slice(0, HYPERPARAMS.MAX_SAMPLE_POSTS_FOR_DESCRIPTION);
  const summaries = samplePosts
    .map(p => `- ${p.summary || p.text.slice(0, 100)}`)
    .join('\n');

  const systemPrompt = `You are creating a title and description for a Topic Space (a collection of related tweets).

Guidelines:
- Title should be catchy but informative (3-6 words)
- Use the canonical label as a strong hint for the title
- Description should be 1-2 sentences explaining what this topic covers
- Base everything ONLY on the tweet summaries provided
- Don't make up information not in the tweets

Return JSON: { "title": "Topic Title", "description": "Brief description" }`;

  const userPrompt = `Canonical label: "${canonicalLabel}"
Number of posts: ${posts.length}

Sample post summaries:
${summaries}`;

  try {
    const response = await grokStrong(
      [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      {
        temperature: HYPERPARAMS.TOPIC_DESCRIPTION_TEMPERATURE,
        response_format: { type: 'json_object' },
      }
    );

    return parseJsonResponse<TopicInfo>(response.content);
  } catch (error) {
    console.error(`  Error generating topic info for "${canonicalLabel}":`, error);
    return {
      title: canonicalLabel,
      description: `${posts.length} posts about ${canonicalLabel.toLowerCase()}.`,
    };
  }
}

/**
 * Create TopicSpaces from classified posts
 */
export async function createTopicSpaces(
  posts: Post[],
  topicType: TopicType,
  generateDescriptions: boolean = true
): Promise<{ topicSpaces: TopicSpace[]; grokCalls: number }> {
  const topicGroups = groupPostsByTopic(posts);
  const topicSpaces: TopicSpace[] = [];
  let grokCalls = 0;

  // For custom topics we must preserve the exact user-provided names.
  // Disable LLM-based title/description generation so titles stay untouched.
  const allowGeneratedDescriptions = generateDescriptions && topicType !== 'custom';

  // Sort topics by number of posts (descending)
  const sortedTopics = Array.from(topicGroups.entries())
    .sort((a, b) => b[1].length - a[1].length);

  for (const [topicLabel, topicPosts] of sortedTopics) {
    let title = topicLabel;
    let description = `${topicPosts.length} posts about ${topicLabel}`;

    if (allowGeneratedDescriptions) {
      try {
        const info = await generateTopicInfo(topicLabel, topicPosts);
        title = info.title;
        description = info.description;
        
        // Only count as Grok call if we actually called Grok
        if (topicLabel !== HYPERPARAMS.LONG_TAIL_LABEL && 
            topicPosts.length >= HYPERPARAMS.MIN_POSTS_FOR_DESCRIPTION) {
          grokCalls++;
        }
      } catch (error) {
        console.error(`  Failed to generate info for topic "${topicLabel}"`);
      }
    }

    const now = new Date().toISOString();
    const lastBookmarkTime = computeLastBookmarkTime(topicPosts);
    
    topicSpaces.push({
      id: uuidv4(),
      title,
      description,
      type: topicType,
      bookmarkTweetIds: topicPosts.map(p => p.id),
      lastBookmarkTime,
      createdAt: now,
      updatedAt: now,
      newPostCount: 0,
    });
  }

  return { topicSpaces, grokCalls };
}

/**
 * Full pipeline: classify bookmarks and create TopicSpaces (auto-discovered topics)
 * With caching, normalization, and topic cap
 */
export async function classifyAndCreateTopicSpaces(
  posts: Post[],
  xUserId: string,
  options: ClassificationOptions = { topicType: 'auto' }
): Promise<{ posts: Post[]; topicSpaces: TopicSpace[]; stats: ClassificationStats }> {
  console.log(`\n=== Starting Classification Pipeline ===`);
  console.log(`  Posts: ${posts.length}, Type: ${options.topicType}, Cache: ${HYPERPARAMS.ENABLE_CACHE ? 'ON' : 'OFF'}, Normalization: ${HYPERPARAMS.ENABLE_NORMALIZATION ? 'ON' : 'OFF'}`);
  
  // Initialize stats
  const stats: ClassificationStats = {
    totalPosts: posts.length,
    cachedPosts: 0,
    classifiedPosts: 0,
    rawLabelCount: 0,
    canonicalLabelCount: 0,
    topicSpaceCount: 0,
    longTailPostCount: 0,
    grokCallsClassification: 0,
    grokCallsNormalization: 0,
    grokCallsDescriptions: 0,
  };

  if (posts.length === 0) {
    return { posts: [], topicSpaces: [], stats };
  }

  // Filter to bookmarks only
  const bookmarkPosts = filterBookmarksOnly(posts);
  console.log(`  Bookmarks: ${bookmarkPosts.length}/${posts.length} posts`);
  
  if (bookmarkPosts.length === 0) {
    console.log('  No bookmarks to classify');
    return { posts: [], topicSpaces: [], stats };
  }
  
  stats.totalPosts = bookmarkPosts.length;

  // Step 1: Classify posts (with caching for auto topics only)
  console.log(`\n[Step 1] Classifying posts...`);
  const { classifiedPosts, stats: classifyStats } = await classifyPosts(bookmarkPosts, xUserId, options);
  stats.cachedPosts = classifyStats.cachedPosts || 0;
  stats.classifiedPosts = classifyStats.classifiedPosts || 0;
  stats.grokCallsClassification = classifyStats.grokCallsClassification || 0;

  // Count raw labels
  const rawLabelCounts = countLabels(classifiedPosts);
  stats.rawLabelCount = rawLabelCounts.size;
  console.log(`  Raw labels: ${stats.rawLabelCount}`);

  let finalPosts = classifiedPosts;

  // For auto topics: apply normalization and topic cap
  // For custom topics: skip these steps since user defined the topics
  if (options.topicType === 'auto') {
    // Step 2: Normalize labels (if enabled)
    console.log(`\n[Step 2] Normalizing labels...`);
    const normResult = await normalizeLabels(rawLabelCounts);
    if (normResult.success && HYPERPARAMS.ENABLE_NORMALIZATION) {
      stats.grokCallsNormalization = 1;
    }
    
    // Step 3: Apply topic cap
    console.log(`\n[Step 3] Applying topic cap...`);
    const finalMapping = applyTopicCap(rawLabelCounts, normResult.mapping);
    
    // Apply mapping to posts
    finalPosts = applyLabelMapping(classifiedPosts, finalMapping);
    
    // Update cache with normalized labels
    if (HYPERPARAMS.ENABLE_CACHE) {
      classificationCache.applyNormalization(xUserId, finalMapping);
    }
    
    // Count canonical labels (excluding Long Tail)
    const canonicalCounts = countLabels(finalPosts);
    stats.canonicalLabelCount = Array.from(canonicalCounts.keys())
      .filter(l => l !== HYPERPARAMS.LONG_TAIL_LABEL).length;
    stats.longTailPostCount = canonicalCounts.get(HYPERPARAMS.LONG_TAIL_LABEL) || 0;
    
    console.log(`  Canonical labels: ${stats.canonicalLabelCount}`);
    if (stats.longTailPostCount > 0) {
      console.log(`  Long Tail posts: ${stats.longTailPostCount}`);
    }
  } else {
    // For custom topics, just count the labels
    stats.canonicalLabelCount = rawLabelCounts.size;
    console.log(`\n[Step 2-3] Skipped (custom topics)`);
  }

  // Step 4: Create TopicSpaces
  console.log(`\n[Step 4] Creating Topic Spaces...`);
  const { topicSpaces, grokCalls: descriptionCalls } = await createTopicSpaces(
    finalPosts, 
    options.topicType
  );
  stats.topicSpaceCount = topicSpaces.length;
  stats.grokCallsDescriptions = descriptionCalls;

  // Log final stats
  if (HYPERPARAMS.LOG_CLASSIFICATION_STATS) {
    console.log(`\n=== Classification Complete ===`);
    console.log(`  Total posts: ${stats.totalPosts}`);
    console.log(`  Cached: ${stats.cachedPosts}, Classified: ${stats.classifiedPosts}`);
    console.log(`  Raw labels: ${stats.rawLabelCount} → Canonical: ${stats.canonicalLabelCount}`);
    console.log(`  Topic Spaces: ${stats.topicSpaceCount} (type: ${options.topicType})`);
    console.log(`  Grok calls: ${stats.grokCallsClassification} classification + ${stats.grokCallsNormalization} normalization + ${stats.grokCallsDescriptions} descriptions`);
    console.log(`================================\n`);
  }

  return { posts: finalPosts, topicSpaces, stats };
}

/**
 * Create custom topic spaces from user-provided topic names
 * Classifies bookmarks into the specified topics
 */
export async function createCustomTopicSpaces(
  posts: Post[],
  xUserId: string,
  topicNames: string[]
): Promise<{ posts: Post[]; topicSpaces: TopicSpace[]; stats: ClassificationStats }> {
  return classifyAndCreateTopicSpaces(posts, xUserId, {
    topicType: 'custom',
    customTopicNames: topicNames,
  });
}
